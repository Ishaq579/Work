<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Robot Hop!</title>
  <style>
    :root{
      --ink:#0f172a;          /* slate-900 */
      --bg:#0b1021;           /* deep navy */
      --card:#10172a;         /* slightly lighter */
      --accent:#38bdf8;       /* sky-400 */
      --good:#22c55e;         /* green-500 */
      --bad:#ef4444;          /* red-500 */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
      color:#e2e8f0; background:radial-gradient(1200px 600px at 50% -30%, #13203d 0%, var(--bg) 50%, #070a16 100%);
      display:grid; place-items:center; padding:16px;
    }
    .wrap{
      width:min(900px, 100%); display:grid; gap:12px;
    }
    header{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
    }
    h1{font-size:clamp(18px, 2.6vw, 28px); margin:0; letter-spacing:.5px}
    .btn{
      appearance:none; border:0; background:var(--accent); color:#00111a; font-weight:700;
      padding:10px 14px; border-radius:14px; box-shadow:0 8px 24px rgba(56,189,248,.25);
      cursor:pointer; transition:transform .06s ease; font-size:14px
    }
    .btn:active{ transform:translateY(1px) }
    .card{
      background:linear-gradient(180deg, #0e162b, #0b1224); border:1px solid #141b33;
      border-radius:18px; padding:10px; box-shadow:0 8px 30px rgba(0,0,0,.35);
    }
    canvas{ width:100%; height:auto; display:block; border-radius:14px; }
    .hud{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; font-size:14px; opacity:.9 }
    .pill{ background:#0e1b36; border:1px solid #1a2747; padding:6px 10px; border-radius:999px }
    .key{ background:#091227; border:1px solid #18264b; padding:3px 8px; border-radius:8px; font-weight:700 }
    footer{font-size:12px; opacity:.7; text-align:center}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>🤖 Robot Hop! <span style="opacity:.6;font-weight:500">— jump over silly stuff</span></h1>
      <button id="btnMute" class="btn" aria-pressed="false">🔊 Sound: On</button>
    </header>

    <div class="card">
      <canvas id="game" width="900" height="320" aria-label="Robot Hop game canvas"></canvas>
    </div>

    <div class="hud">
      <div class="pill">Controls: <span class="key">Space</span>/<span class="key">↑</span> or Tap to Jump · <span class="key">R</span> Restart</div>
      <div id="hudInfo" class="pill">Tip: Time your jumps — speed increases!</div>
    </div>

    <footer>Built with plain HTML5 Canvas + Web Audio. No images, just emoji ✨</footer>
  </div>

<script>
(() => {
  // --- Helpers -------------------------------------------------------------
  const clamp = (n,min,max)=>Math.max(min,Math.min(max,n));
  const rand = (a,b)=>Math.random()*(b-a)+a;

  // --- Audio (Web Audio API) ----------------------------------------------
  let audioCtx; // created on first user gesture (mobile policies)
  let muted = false;
  const btnMute = document.getElementById('btnMute');
  btnMute.addEventListener('click', () => {
    muted = !muted; btnMute.textContent = muted ? '🔇 Sound: Off' : '🔊 Sound: On';
    btnMute.setAttribute('aria-pressed', String(!muted));
  });
  function ensureAudio(){
    if (!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  }
  function beep({type='sine', freq=440, duration=0.12, volume=0.2, slideTo=null}){
    if (muted) return; ensureAudio();
    const t0 = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type; osc.frequency.setValueAtTime(freq, t0);
    if (slideTo){ osc.frequency.exponentialRampToValueAtTime(Math.max(1,slideTo), t0 + duration*0.9); }
    gain.gain.setValueAtTime(0, t0);
    gain.gain.linearRampToValueAtTime(volume, t0+0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0+duration);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(t0); osc.stop(t0+duration+0.02);
  }
  function noiseHit(duration=0.18){
    if (muted) return; ensureAudio();
    const bufferSize = audioCtx.sampleRate * duration;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * Math.pow(1 - i/bufferSize, 2);
    const src = audioCtx.createBufferSource(); src.buffer = buffer;
    const biquad = audioCtx.createBiquadFilter(); biquad.type='bandpass'; biquad.frequency.value=600;
    const gain = audioCtx.createGain(); gain.gain.value=0.35;
    src.connect(biquad).connect(gain).connect(audioCtx.destination);
    src.start();
  }

  // --- Canvas --------------------------------------------------------------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.min(2, window.devicePixelRatio || 1);
  function fitCanvas(){
    const w = 900, h = 320; // internal design size
    canvas.width = w * DPR; canvas.height = h * DPR; canvas.style.height = h + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  fitCanvas();
  addEventListener('resize', fitCanvas);

  // --- Game State ----------------------------------------------------------
  const GROUND_Y = 260;
  const gravity = 0.75;
  const jumpV = -12.2;
  let speed = 5;            // base horizontal speed
  let speedUp = 0.0009;     // per frame increment
  let gameOver = false;
  let started = false;
  let score = 0;
  let hi = Number(localStorage.getItem('robotHopHi')||0);
  let spawnTimer = 0;
  let spawnGap = 90; // frames between spawns baseline
  const silly = ['🛁','🍌','🦆','🧦','🧻','🪩','🧃','🪵','🧽','🪑'];

  const player = {
    x: 110, y: GROUND_Y, w: 28, h: 36, vy: 0, onGround: true, 
    draw(){
      // body
      ctx.fillStyle = '#68e1fd22';
      ctx.fillRect(this.x-6, this.y-6, this.w+12, this.h+12);
      // robot emoji
      ctx.font = '32px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji';
      ctx.textBaseline = 'top';
      ctx.fillText('🤖', this.x-2, this.y-4);
      // tiny eye blink as speed increases
      if ((Math.floor(performance.now()/500) % 6)===0){
        ctx.fillStyle = '#0ff'; ctx.fillRect(this.x+14, this.y+10, 2, 2);
      }
    }
  };

  const obstacles = [];
  function makeObstacle(){
    const emoji = silly[(Math.random()*silly.length)|0];
    const size = 28 + Math.floor(rand(-4, 12));
    const w = size, h = size;
    return { x: canvas.width/DPR + 20, y: GROUND_Y + (32 - h), w, h, emoji, passed:false };
  }

  // --- Controls ------------------------------------------------------------
  function doJump(){
    if (!started){ started = true; beep({type:'triangle', freq:520, slideTo:980, duration:0.11}); return; }
    if (gameOver) return;
    if (player.onGround){
      player.vy = jumpV; player.onGround = false;
      beep({type:'square', freq:680, slideTo:1120, duration:0.13, volume:0.18});
    }
  }
  addEventListener('keydown', e=>{
    if (e.code==='Space' || e.code==='ArrowUp') { e.preventDefault(); doJump(); }
    if (e.code==='KeyR'){ reset(); }
  });
  canvas.addEventListener('pointerdown', doJump);
  window.addEventListener('blur', () => started && (paused = true));

  // --- Game Loop -----------------------------------------------------------
  let paused = false;
  function reset(){
    gameOver = false; started = false; score = 0; speed = 5; spawnTimer = 0; obstacles.length = 0; paused = false;
  }
  function aabb(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function update(){
    if (!started || paused || gameOver) return draw();

    // physics
    player.vy += gravity; player.y += player.vy;
    if (player.y >= GROUND_Y){ player.y = GROUND_Y; player.vy = 0; player.onGround = true; }

    // obstacles
    spawnTimer--;
    if (spawnTimer <= 0){
      obstacles.push(makeObstacle());
      spawnGap = Math.max(48, 90 - Math.floor(score/50));
      spawnTimer = Math.floor(rand(spawnGap*0.6, spawnGap*1.3));
    }
    for (let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i]; o.x -= speed;
      // scoring when passed
      if (!o.passed && o.x + o.w < player.x){ o.passed = true; score++; if (score%10===0) beep({type:'sine',freq:480,slideTo:760,duration:0.12}); }
      // collision box smaller to be fair
      const hitbox = {x:player.x+4,y:player.y+2,w:player.w-8,h:player.h-4};
      const obox = {x:o.x+4,y:o.y+4,w:o.w-8,h:o.h-8};
      if (aabb(hitbox, obox)){
        gameOver = true; noiseHit();
        hi = Math.max(hi, score); localStorage.setItem('robotHopHi', hi);
      }
      if (o.x + o.w < -40) obstacles.splice(i,1);
    }

    // speed up over time
    speed += speedUp; if (Math.floor(speed*100)%100===0){ /* subtle milestones */ }

    draw();
  }

  function drawBg(){
    // sky gradient
    const g = ctx.createLinearGradient(0,0,0,canvas.height/DPR);
    g.addColorStop(0,'#0b142b'); g.addColorStop(1,'#070c1c');
    ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);

    // ground
    ctx.fillStyle = '#0c1733';
    ctx.fillRect(0, GROUND_Y + 32, canvas.width/DPR, 999);

    // parallax stars/dots
    const t = performance.now()*0.0002;
    for (let i=0;i<40;i++){
      const x = (i*97 + t*200) % (canvas.width/DPR);
      const y = 40 + (i*37 % 140);
      ctx.fillStyle = 'rgba(56,189,248,.15)';
      ctx.fillRect(x, y, 2, 2);
    }
  }

  function draw(){
    drawBg();

    // ground line
    ctx.strokeStyle = '#1a2547'; ctx.lineWidth = 2; ctx.beginPath();
    ctx.moveTo(0, GROUND_Y + 32.5); ctx.lineTo(canvas.width/DPR, GROUND_Y + 32.5); ctx.stroke();

    // obstacles
    ctx.font = '28px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji';
    for (const o of obstacles){ ctx.fillText(o.emoji, o.x, o.y - 4); }

    // player
    player.draw();

    // HUD
    ctx.fillStyle = '#94a3b8'; ctx.font = '14px system-ui, Segoe UI, Roboto, Arial';
    ctx.fillText(`Speed: ${speed.toFixed(2)}`, 16, 16);
    ctx.fillText(`Score: ${String(score).padStart(3,'0')}  ·  Best: ${String(hi).padStart(3,'0')}`, 16, 36);

    if (!started){
      const msg = 'Tap or Press Space to Start';
      ctx.font = 'bold 20px system-ui'; ctx.fillStyle = '#cbd5e1';
      const tw = ctx.measureText(msg).width;
      ctx.fillText(msg, (canvas.width/DPR - tw)/2, 110);
      ctx.font = '14px system-ui'; ctx.fillStyle = '#94a3b8';
      const msg2 = 'Jump over 🛁 🍌 🦆 🧦 🧻 · Avoid collisions!';
      const tw2 = ctx.measureText(msg2).width;
      ctx.fillText(msg2, (canvas.width/DPR - tw2)/2, 136);
    }

    if (gameOver){
      // overlay
      ctx.fillStyle = 'rgba(0,0,0,.45)';
      ctx.fillRect(0,0,canvas.width/DPR,canvas.height/DPR);
      ctx.font = 'bold 28px system-ui'; ctx.fillStyle = '#fecaca';
      const t1='CRASH!'; const w1 = ctx.measureText(t1).width;
      ctx.fillText(t1, (canvas.width/DPR - w1)/2, 98);
      ctx.font = '16px system-ui'; ctx.fillStyle = '#e2e8f0';
      const t2=`Score ${score} · Best ${hi}`; const w2 = ctx.measureText(t2).width;
      ctx.fillText(t2, (canvas.width/DPR - w2)/2, 128);
      const t3='Press R to Restart'; const w3 = ctx.measureText(t3).width;
      ctx.fillText(t3, (canvas.width/DPR - w3)/2, 154);
    }
  }

  // main loop
  function loop(){ update(); requestAnimationFrame(loop); }
  draw(); loop();
})();
</script>
</body>
</html>


I built you a one-file HTML game you can play right here: tap/Space to jump the 🤖 over silly emoji obstacles (bananas, ducks, socks…), speed ramps up over time, and there are jump/crash/level-up sound effects. High score is saved locally.

Want tweaks? I can add double-jump, moving clouds, power-ups, custom sprites, or a “hard mode.”

